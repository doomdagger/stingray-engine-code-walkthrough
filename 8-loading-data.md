# Part 8: Loading and unloading data



## Loading data

* Data is loaded/unloaded in Packages
* `resource_package.h`
     * `load()` -- queue for loading
	   * `is_complete()` -- query for completion
* load() calls `ResourceManager::load_resource()` on each resource
	* Queues the load with `ResourceLoader::add_request()`
	* `resource_package.cpp`
	* `resource_manager.cpp`
	* `resource_loader.h`
* To know when a package laod is done a sentinel (fence) is queued on the resource loader
	* Can query for that sentinel being reached



## Resource loader thread

* Go through each request posted on request queue
* `resource_loader.cpp`
	* Unless request is marked as skip or cancel
	* Load it from bundle or database into memory
	* Put the result on the result queue



## Processing completed requests

* `resource_manager.cpp` `complete_request()`
	* Store loaded data into lookup table
	* Store stream references in lookup table
	* Increase refcount



## Unload

* Similar procedure -- package unloads all resources
	* Resource manager decreases `refcount`
	* If zero -- memory is freed



## Patching up resources

* Most resources require no patching -- binary blob straight into memory
* But some do: old serialization code
* Two possibilities
	* `load()` -- callback on resource loader thread to deserialize data
	  Doesn't stall main thread
	* `bring_in()` -- callback on main thread when added to resource manager
	  Can query for other resources and create links
* Registered in `application.cpp` `setup_resources()` (or plugins)



## Accessing resources

* Once resources have been loaded they can be accessed from `resource_manager.h`
	* `can_get()`, `get()`, `open_stream()`
* Note: Getting a resource doesn't "lock" it
	* Unload a resource that is in use ==> CRASH
* Optional locking through `lock()`, `unlock()` -- reference counted
	* Unload a resource that is locked ==> ERROR MESSAGE, then CRASH
	* Should we reference count/garbage collect instead?
	* Nah!



## Autoloading

* What about the editor viewport? We don't know which units the user might spawn?
* What package should we load?
* Autoload to the rescue:
	* When autoload is enabled, we don't use packages, but load on `get()`
	* `can_get()` always returns true
	* `autoload = true` in `settings.ini`
	* `Application.set_autoload_enabled(true)`
	* Super convenient
* Autoloaded resources are never released
* So in the editor the engine never releases any resource memory???
	* Seems to work in practice
	* Mumble mumble, virtual memory


## Hot-reloading

* Fast compile times don't mean anything without hot reloading
* `Console.refresh()`
* `game.cpp`
	* Find all the resources that have changed since last refresh (compiler stores a list)
	* Load the new resources into memory
	* Patch instances to point to new resources
	* `unit.cpp`
	* Unload the old resources from memory
* Lots of bookkeeping in `resource_manager.cpp` to make sure locks and refcounts are
  counted correctly during hot reload, autoload, etc



## Patch bundles

* Problem: Fixing a game after it has been released
	* Bundles are compressed -- so small changes could become big ones
	* Solution: Patch bundles -- just the resources that have been modified since last bundle
	* Same format as bundles
	* `bundle.h`
	* Named: `209fb8c3c0a8c3a4.patch_0`, `209fb8c3c0a8c3a4.patch_1`, ...
	* Loaded sequentially after original bundle -- last one is authorative
	* `exists` flag can be used to remove resources in a patch bundle
* Generated by old tool `Patch Builder`
	* Take as input two project folders
	* Computes the patch bundles between them
* Up to project how to organize patches



## DLCs and MODs

* Extend a project with downloadable or user generated content
* Based on bundle architecture
	* DLCs are bundles that you can list and load optionally
	* `dlc_list.h`
	* MODs are more complicated, allows patching resources in all bundles
	* Will not go into details (not sure if they have ever been used)



## Override resolution

* Happens in resource manager
* `resource_manager.cpp`
